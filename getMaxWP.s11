
.=torg+1000
main:
     mov #main, sp
     mov #SrcPos, -(sp)
     mov #DstPos, -(sp)
     mov #WP, -(sp)
     jsr pc, getMaxWP
     halt

getMaxWP:
  mov #0, -(sp) ; Allocating source position.
  mov #0, -(sp) ; Allocating destenation position.
  mov #-100., -(sp) ; Allocating place for WP.
  mov #1, -(sp) ;  Maximum for the first player.
  mov Player, -(sp) ; Moving the player we check for to the stack.
  mov Steps, -(sp) ; Moving number of steps to stack.
  jsr pc, getWPRec
  add #6, sp
  mov (sp)+, @6.(sp) ; Writing the best wp to WinParam label.
  sub #Board, (sp) ;
  mov r0, -(sp)
  mov r1, -(sp)
  clr r0
  mov 4(sp), r1
  div #2, r0
  mov r0, @12.(sp)
  clr r0
  sub #Board, 6(sp)
  mov 6(sp), r1
  div #2, r0
  mov r0, @14.(sp)
  mov (sp)+, r1
  mov (sp)+, r0
  add #4, sp
  rts pc


getWPRec:
 ; --- STOP TERMS ---
 ; Preparing to call for checkWin with the previous player (last player to move).
 mov #Board, -(sp) ; Moving board adress to stack.
 ; Pushing to stack the last player to make a move.
 mov #3, -(sp)
 sub 6(sp), (sp) ; Moving current player to the top of the stack.
 mov #0, -(sp) ; checkWin Output will be written to here.

 jsr pc, checkWin ; CheckWin will use the place allocted for r0 in the stack for output.
 cmp #1, (sp)+ ; Pop the return value of checkWin and check which player won.
 beq whoWon ; If last player wins - jumps.

 ; If we got here last player didn't win
 add #4, sp ; Pop the other player and board from the stack.
 tst 2(sp) ; Check if the current number of steps is 0.
 bne chkMoves

 ; If we got here steps is 0.
 mov #Board, -(sp) ; Moving board adress to stack.
 mov 6(sp), -(sp) ; Moving current player to the top of the stack.
 jsr pc, calcWP ; Output will be at r4.
 add #4, sp
 mov r4, 8.(sp) ; Copying calculated wp from r4 to the fathers wp.
 rts pc

 whoWon:
   cmp (sp)+, Player ; Check if the current player is the same as found in label Player.
   bne playerLos
   ; The player who won is the player we check
   mov #20., 10.(sp)
   tst (sp)+
   rts pc
   playerLos:
     ;The player who won is not the player we check.
     mov #-20., 10.(sp)
     tst (sp)+
     rts pc
; --- END OF STOP TERMS ---



     ; r0 - Current row index.
     ; r1 - Current column index.
     chkMoves:
           clr r0 ; Sets r0 to 0.
           clr r1 ; Sets r1 to 0.
           cmp 4(sp), #1 ; Checking if the current color is white.
           bne jBlack ; If the color is not white, branch to Black.
           br jWhite ; If the color is white, branch to White.

           jBlack:
             jmp Black

             jWhite:
               jmp White

               jNxtCll0:
                 jmp NextCell

               jLeftW0:
                 jmp LeftW


                 ; This method will check legal moves of all white pieces and add 1 to NumMoves each time a legal move is found.
                 ; r2- current cell address.
                 ; r3 - temporary row index (will be used once for another calculation).
                 ; r5 - temporary column index (will be used once for another calculation).
                 White:
                   mov r0, r3  ; Putting index of the current row in r3.
                   mov r1, r5  ; Putting index of the current column in r5.
                   mov #Board, r2 ; Putting board array starting index in r2.
                   mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
                   mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
                   add r3, r2 ; Adding the number of bytes needed in order to point to the beginning of a row.
                   add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
                   ; r2 will now contain the address of the current cell.
                   cmp (r2), #1 ; Checking if the current piece is white.
                   bne jNxtCll0 ; If the color of the current piece is not white skip to the next cell.
                   mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
                   sub #1, r3 ; Reducing row index by 1.
                   cmp r3, #0
                   blt jNxtCll0 ; If row index is less than 0, cannot move at all, skip to the next cell.
                   mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
                   add #1, r5 ; Increasing column index by 1.
                   cmp r5, #7
                   bgt jLeftW0 ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
                   cmp -14.(r2), #1 ; Checking if the upper right piece is white.
                   beq jLeftW0 ; If the upper right piece is white, cannot go there, check legal moves to the left.
                   cmp -14.(r2), #2 ; Checking if the upper right piece is black.
                   beq EatRW ; If the upper right piece is black, check if the white piece can eat it.

                   ; --- WHITE MOVE RIGHT ---
                   ; Making the move of the white player.
                   mov #1, -14.(r2) ; Moving white piece to the new place.
                   mov #0, (r2) ; Removing white piece from the last place it was.

                   ; Backing up registers before calling the REC function.
                   mov r0, -(sp) ; Backing up r0.
                   mov r1, -(sp) ; Backing up r1.
                   mov r2, -(sp) ; Backing up r2.
                   mov r3, -(sp) ; Backing up r3.
                   mov r5, -(sp) ; Backing up r5.

                   ; Preparing the arguments for the REC function.
                   mov #0, -(sp) ; Allocating source position.
                   mov #0, -(sp) ; Allocating destenation position.
                   cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
                   beq chngMin0 ; Changing maximum to minimum.
                   mov #-100., -(sp) ; Miminum was checked in the last call.
                   mov #1, -(sp) ; Maximum will be checked.
                   br changed0

                   chngMin0: ; Changing maximum to minimum.
                     mov #100., -(sp) ; Maximum was checked in the last call.
                     mov #-1., -(sp) ; Minimum will be checked.

                     changed0: ; Changed maximum\minimum value.
                       mov #3, -(sp)
                       sub 24.(sp), (sp) ; Chaning to the other player.
                       mov 22.(sp), -(sp) ; Copying last number of steps.
                       sub #1, (sp) ; Substract 1 from number of steps.
                       jsr pc, getWPRec
                       cmp 28.(sp), #1 ; The father is looking for a maximum.
                       beq upMax0 ; Father was looking for a maximum.
                       ; Father was looking for a minimum.
                       cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                       bgt nUpdate0
                       ;Updating father wp , src and dest.
                       mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
                       add #12., sp ; Popping all values besides registers backup.
                       mov (sp)+, r5
                       mov (sp)+, r3
                       mov (sp)+, r2
                       mov (sp)+, r1
                       mov (sp)+, r0
                       mov #0, -14.(r2) ; Moving white piece to the previous place.
                       mov #1, (r2)
                       mov r2, 12.(sp) ; Updating father src.
                       mov r2, 10.(sp) ; Updating father dest.
                       sub #14., 10.(sp)
                       br jLeftW0

                       upMax0:
                         cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                         ble nUpdate0
                         mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                         add #12., sp ; Popping all values besides registers backup.
                         mov (sp)+, r5
                         mov (sp)+, r3
                         mov (sp)+, r2
                         mov (sp)+, r1
                         mov (sp)+, r0
                         mov #0, -14.(r2) ; Moving white piece to the previous place.
                         mov #1, (r2)
                         mov r2, 12.(sp) ; Updating father src.
                         mov r2, 10.(sp) ; Updating father dest.
                         sub #14., 10.(sp)
                         br jLeftWZ

                         jLeftWZ:
                           jmp LeftW
                           nUpdate0:
                             add #12., sp ; Popping all values besides registers backup.
                             mov (sp)+, r5
                             mov (sp)+, r3
                             mov (sp)+, r2
                             mov (sp)+, r1
                             mov (sp)+, r0
                             mov #0, -14.(r2) ; Moving white piece to the previous place.
                             mov #1, (r2)
                             br jLeftW1 ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).

                             jLeftW1:
                               jmp LeftW

                               ;This method will check an eating option for white pieces to the right.
                               ; r2- current cell address.
                               ; r3 - temporary row index .
                               ; r5 - temporary column index.
                               EatRW:
                                 sub #1, r3 ; Reducing row index by 1.
                                 cmp r3, #0
                                 blt jLeftW1 ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
                                 add #1, r5 ;Increasing column index by 1.
                                 cmp r5, #7
                                 bgt jLeftW1 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
                                 ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
                                 cmp -28.(r2), #0 ; Checking if the cell is empty.
                                 bne jLeftW1 ; If the cell is not empty, cannot eat. Check legal moves to the left.

                                 ; --- WHITE EAT RIGHT ---
                                 ; Making the move of the white player.
                                 mov #1, -28.(r2) ; Moving white piece to the new place.
                                 mov #0, -14.(r2) ; Removing eaten piece.
                                 mov #0, (r2) ; Removing white piece from the last place it was.

                                 ; Backing up registers before calling the REC function.
                                 mov r0, -(sp) ; Backing up r0.
                                 mov r1, -(sp) ; Backing up r1.
                                 mov r2, -(sp) ; Backing up r2.
                                 mov r3, -(sp) ; Backing up r3.
                                 mov r5, -(sp) ; Backing up r5.

                                 ; Preparing the arguments for the REC function.
                                 mov #0, -(sp) ; Allocating source position.
                                 mov #0, -(sp) ; Allocating destenation position.
                                 cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
                                 beq chngMin1 ; Changing maximum to minimum.
                                 mov #-100., -(sp) ; Miminum was checked in the last call.
                                 mov #1, -(sp) ; Maximum will be checked.
                                 br changed1

                                 chngMin1: ; Changing maximum to minimum.
                                   mov #100., -(sp) ; Maximum was checked in the last call.
                                   mov #-1., -(sp) ; Minimum will be checked.

                                   changed1: ; Changed maximum\minimum value.
                                     mov #3, -(sp)
                                     sub 24.(sp), (sp) ; Chaning to the other player.
                                     mov 22.(sp), -(sp) ; Copying last number of steps.
                                     sub #1, (sp) ; Substract 1 from number of steps.
                                     jsr pc, getWPRec
                                     cmp 28.(sp), #1 ; The father is looking for a maximum.
                                     beq upMax1 ; Father was looking for a maximum.
                                     ; Father was looking for a minimum.
                                     cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                                     bgt nUpdate1
                                     ;Updating father wp , src and dest.
                                     mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
                                     add #12., sp ; Popping all values besides registers backup.
                                     mov (sp)+, r5
                                     mov (sp)+, r3
                                     mov (sp)+, r2
                                     mov (sp)+, r1
                                     mov (sp)+, r0
                                     mov #0, -28.(r2) ; Moving white piece to the new place.
                                     mov #2, -14.(r2) ; Removing eaten piece.
                                     mov #1, (r2) ; Removing white piece from the last place it was.
                                     mov r2, 12.(sp) ; Updating father src.
                                     mov r2, 10.(sp) ; Updating father dest.
                                     sub #28., 10.(sp)
                                     br jLeftW1


                                     upMax1:
                                       cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                                       ble nUpdate0
                                       mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                                       add #12., sp ; Popping all values besides registers backup.
                                       mov (sp)+, r5
                                       mov (sp)+, r3
                                       mov (sp)+, r2
                                       mov (sp)+, r1
                                       mov (sp)+, r0
                                       mov #0, -28.(r2) ; Moving white piece to the new place.
                                       mov #2, -14.(r2) ; Removing eaten piece.
                                       mov #1, (r2) ; Removing white piece from the last place it was.
                                       mov r2, 12.(sp) ; Updating father src.
                                       mov r2, 10.(sp) ; Updating father dest.
                                       sub #28., 10.(sp)
                                       br jLeftW1

                                       nUpdate1:
                                         add #12., sp ; Popping all values besides registers backup.
                                         mov (sp)+, r5
                                         mov (sp)+, r3
                                         mov (sp)+, r2
                                         mov (sp)+, r1
                                         mov (sp)+, r0
                                         mov #0, -28.(r2) ; Moving white piece to the new place.
                                         mov #2, -14.(r2) ; Removing eaten piece.
                                         mov #1, (r2) ; Removing white piece from the last place it was.
                                         br jLeftW2 ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).

                                         jLeftW2:
                                           jmp LeftW



                                           ; This method will check legal moves of white pieces to the left.
                                           ; r2- current cell address.
                                           ; r3 - temporary row index .
                                           ; r5 - temporary column index.
                                           LeftW:
                                             mov r0, r3 ; Putting index of the current row in r3.
                                             sub #1, r3 ; Reducing row index by 1.
                                             mov r1, r5 ; Putting index of the current column in r5.
                                             sub #1, r5 ; Reducing column index by 1.
                                             cmp r5, #0
                                             blt jNxtCll1 ; If column index is less than 0, cannot move right, skip to the next cell.
                                             cmp -18.(r2), #1 ; Checking if the upper left piece is white.
                                             beq jNxtCll1 ; If the upper left piece is white, cannot move there, skip to the next cell.
                                             cmp -18.(r2), #2 ; Checking if the upper left piece is black.
                                             beq EatLW ; If the upper left piece is black, Check if the white piece can eat it.

                                             ; --- WHITE MOVE LEFT ---
                                             ; Making the move of the white player.
                                             mov #1, -18.(r2) ; Moving white piece to the new place.
                                             mov #0, (r2) ; Removing white piece from the last place it was.

                                             ; Backing up registers before calling the REC function.
                                             mov r0, -(sp) ; Backing up r0.
                                             mov r1, -(sp) ; Backing up r1.
                                             mov r2, -(sp) ; Backing up r2.
                                             mov r3, -(sp) ; Backing up r3.
                                             mov r5, -(sp) ; Backing up r5.

                                             ; Preparing the arguments for the REC function.
                                             mov #0, -(sp) ; Allocating source position.
                                             mov #0, -(sp) ; Allocating destenation position.
                                             cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
                                             beq chngMin2 ; Changing maximum to minimum.
                                             mov #-100., -(sp) ; Miminum was checked in the last call.
                                             mov #1, -(sp) ; Maximum will be checked.
                                             br changed2

                                             chngMin2: ; Changing maximum to minimum.
                                               mov #100., -(sp) ; Maximum was checked in the last call.
                                               mov #-1., -(sp) ; Minimum will be checked.

                                               changed2: ; Changed maximum\minimum value.
                                                 mov #3, -(sp)
                                                 sub 24.(sp), (sp) ; Chaning to the other player.
                                                 mov 22.(sp), -(sp) ; Copying last number of steps.
                                                 sub #1, (sp) ; Substract 1 from number of steps.
                                                 jsr pc, getWPRec
                                                 cmp 28.(sp), #1 ; The father is looking for a maximum.
                                                 beq upMax2 ; Father was looking for a maximum.
                                                 ; Father was looking for a minimum.
                                                 cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                                                 bgt nUpdate2
                                                 ;Updating father wp , src and dest.
                                                 mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
                                                 add #12., sp ; Popping all values besides registers backup.
                                                 mov (sp)+, r5
                                                 mov (sp)+, r3
                                                 mov (sp)+, r2
                                                 mov (sp)+, r1
                                                 mov (sp)+, r0
                                                 mov #0, -18.(r2) ; Moving white piece to the previous place.
                                                 mov #1, (r2)
                                                 mov r2, 12.(sp) ; Updating father src.
                                                 mov r2, 10.(sp) ; Updating father dest.
                                                 sub #18., 10.(sp)
                                                 br jNxtCll1

                                                 jNxtCll1:
                                                   jmp NextCell

                                                   upMax2:
                                                     cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                                                     ble nUpdate2
                                                     mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                                                     add #12., sp ; Popping all values besides registers backup.
                                                     mov (sp)+, r5
                                                     mov (sp)+, r3
                                                     mov (sp)+, r2
                                                     mov (sp)+, r1
                                                     mov (sp)+, r0
                                                     mov #0, -18.(r2) ; Moving white piece to the previous place.
                                                     mov #1, (r2)
                                                     mov r2, 12.(sp) ; Updating father src.
                                                     mov r2, 10.(sp) ; Updating father dest.
                                                     sub #18., 10.(sp)
                                                     br jNxtCll1

                                                     nUpdate2:
                                                       add #12., sp ; Popping all values besides registers backup.
                                                       mov (sp)+, r5
                                                       mov (sp)+, r3
                                                       mov (sp)+, r2
                                                       mov (sp)+, r1
                                                       mov (sp)+, r0
                                                       mov #0, -18.(r2) ; Moving white piece to the previous place.
                                                       mov #1, (r2)
                                                       br jNxtCll1 ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).


                                                       ;This method will check an eating option for white pieces to the left.
                                                       ; r2- current cell address.
                                                       ; r3 - temporary row index .
                                                       ; r5 - temporary column index.
                                                       EatLW:
                                                         sub #1, r5 ; Reducing column index by 1.
                                                         cmp r5, #0
                                                         blt jNxtCll1 ; If column index is less than 0, cannot eat, skip to the next cell.
                                                         sub #1, r3 ; Reducing row index by 1.
                                                         cmp r3, #0
                                                         blt jNxtCll1 ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
                                                         ;If we got here, the cell which the current white piece should be
                                                         ;placed in after eating is in the board bounds, Check if it is empty.
                                                         cmp -36.(r2), #0 ; Checking if the cell is empty.
                                                         bne jNxtCll1 ;If the cell is not empty, cannot eat. Skip to the next cell.

                                                         ; --- WHITE EAT LEFT ---
                                                         ; Making the move of the white player.
                                                         mov #1, -36.(r2) ; Moving white piece to the new place.
                                                         mov #0, -18.(r2) ; Removing eaten piece.
                                                         mov #0, (r2) ; Removing white piece from the last place it was.

                                                         ; Backing up registers before calling the REC function.
                                                         mov r0, -(sp) ; Backing up r0.
                                                         mov r1, -(sp) ; Backing up r1.
                                                         mov r2, -(sp) ; Backing up r2.
                                                         mov r3, -(sp) ; Backing up r3.
                                                         mov r5, -(sp) ; Backing up r5.

                                                         ; Preparing the arguments for the REC function.
                                                         mov #0, -(sp) ; Allocating source position.
                                                         mov #0, -(sp) ; Allocating destenation position.
                                                         cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
                                                         beq chngMin3 ; Changing maximum to minimum.
                                                         mov #-100., -(sp) ; Miminum was checked in the last call.
                                                         mov #1, -(sp) ; Maximum will be checked.
                                                         br changed3

                                                         chngMin3: ; Changing maximum to minimum.
                                                           mov #100., -(sp) ; Maximum was checked in the last call.
                                                           mov #-1., -(sp) ; Minimum will be checked.

                                                           changed3: ; Changed maximum\minimum value.
                                                             mov #3, -(sp)
                                                             sub 24.(sp), (sp) ; Chaning to the other player.
                                                             mov 22.(sp), -(sp) ; Copying last number of steps.
                                                             sub #1, (sp) ; Substract 1 from number of steps.
                                                             jsr pc, getWPRec
                                                             cmp 28.(sp), #1 ; The father is looking for a maximum.
                                                             beq upMax3 ; Father was looking for a maximum.
                                                             ; Father was looking for a minimum.
                                                             cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                                                             bgt nUpdate3
                                                             ;Updating father wp , src and dest.
                                                             mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
                                                             add #12., sp ; Popping all values besides registers backup.
                                                             mov (sp)+, r5
                                                             mov (sp)+, r3
                                                             mov (sp)+, r2
                                                             mov (sp)+, r1
                                                             mov (sp)+, r0
                                                             mov #0, -36.(r2) ; Moving white piece to the previous place.
                                                             mov #2, -18.(r2)
                                                             mov #1, (r2)
                                                             mov r2, 12.(sp) ; Updating father src.
                                                             mov r2, 10.(sp) ; Updating father dest.
                                                             sub #36., 10.(sp)
                                                             br jNxtCllz

                                                             jNxtCllz:
                                                               jmp NextCell

                                                               upMax3:
                                                                 cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                                                                 ble nUpdate3
                                                                 mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                                                                 add #12., sp ; Popping all values besides registers backup.
                                                                 mov (sp)+, r5
                                                                 mov (sp)+, r3
                                                                 mov (sp)+, r2
                                                                 mov (sp)+, r1
                                                                 mov (sp)+, r0
                                                                 mov #0, -36.(r2) ; Moving white piece to the previous place.
                                                                 mov #2, -18.(r2)
                                                                 mov #1, (r2)
                                                                 mov r2, 12.(sp) ; Updating father src.
                                                                 mov r2, 10.(sp) ; Updating father dest.
                                                                 sub #36., 10.(sp)
                                                                 br jNxtCll2

                                                                 jNxtCll2:
                                                                   jmp NextCell

                                                                   nUpdate3:
                                                                     add #12., sp ; Popping all values besides registers backup.
                                                                     mov (sp)+, r5
                                                                     mov (sp)+, r3
                                                                     mov (sp)+, r2
                                                                     mov (sp)+, r1
                                                                     mov (sp)+, r0
                                                                     mov #0, -36.(r2) ; Moving white piece to the previous place.
                                                                     mov #2, -18.(r2)
                                                                     mov #1, (r2)
                                                                     br jNxtCll2 ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).


                                                                     End: ;If we got here we checked all the cells of the array.
                                                                       rts pc


                                                                       ; This method will skip to the next cell by adding 1 to column index. If column
                                                                       ; index is bigger than 7 sets it to 0 and adds 1 to row index.
                                                                       ; r0 - Current row index.
                                                                       ; r1 - Current column index.
                                                                       NextCell:
                                                                         add #1, r1 ; Increasing column index by 1.
                                                                         cmp r1, #8 ; Checking if reached the end of the row.
                                                                         blt InRange ; Branch to InRange if the index of column is legal.
                                                                         clr r1 ; If we got here index of column reached the end of row. Sets it to 0.
                                                                         add #1, r0 ; Go to the next row.
                                                                         cmp r0, #7
                                                                         bgt End ; If index of row is bigger than 7 we reached the end of the board.

                                                                         ;Continues to the next cell once its indexes are valid.
                                                                         InRange:
                                                                           cmp 4(sp), #1
                                                                           bne jBlackz
                                                                           br jWhite1

                                                                           jWhite1:
                                                                             jmp White

jRightB:
  jmp RightB


;This method will check legal moves of all black pieces and add 1 to NumMoves
;each time a legal move is found.
; r2- current cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
Black:
      mov r0, r3  ; Putting index of the current row in r3.
      mov r1, r5  ; Putting index of the current column in r5.
      mov #Board, r2 ; Putting board array starting index in r2.
      mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
      mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
      add r3, r2 ;Adding the number of bytes needed in order to point to the beginning of a row.
      add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
      ; r2 will now contain the address of the current cell.
      cmp (r2), #2 ; Checking if the current piece is black.
      bne jNxtCll2 ; If the color of the current piece is not black skip to the next cell.
      mov r0, r3 ; Putting index of the current row in r3.
      add #1, r3 ; Increasing row index by 1.
      cmp r3, #7
      bgt jNxtCll2 ; If row index is bigger than 7, cannot move at all, skip to the next cell.
      mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
      add #1, r5 ; Increasing column index by 1.
      cmp r5, #7
      bgt jRightB ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
      cmp 18.(r2), #2 ; Checking if the lower right piece is black.
      beq jRightB ; If the lower left piece is black, cannot go there, Check legal moves to the right.
      cmp 18.(r2), #1 ; Checking if the lower right piece is black.
      beq EatLB ; If the lower right piece is white, check if the black piece can eat it.


      ; --- BLACK MOVE LEFT ---
      ; Making the move of the black player.

      mov #2, 18.(r2) ; Moving black piece to the new place.
      mov #0, (r2) ; Removing black piece from the last place it was.

      ; Backing up registers before calling the REC function.
      mov r0, -(sp) ; Backing up r0.
      mov r1, -(sp) ; Backing up r1.
      mov r2, -(sp) ; Backing up r2.
      mov r3, -(sp) ; Backing up r3.
      mov r5, -(sp) ; Backing up r5.

      ; Preparing the arguments for the REC function.
      mov #0, -(sp) ; Allocating source position.
      mov #0, -(sp) ; Allocating destenation position.
      cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
      beq chngMin4 ; Changing maximum to minimum.
      mov #-100., -(sp) ; Miminum was checked in the last call.
      mov #1, -(sp) ; Maximum will be checked.
      br changed4

      chngMin4: ; Changing maximum to minimum.
      mov #100., -(sp) ; Maximum was checked in the last call.
      mov #-1., -(sp) ; Minimum will be checked.

      changed4: ; Changed maximum\minimum value.
        mov #3, -(sp)
        sub 24.(sp), (sp) ; Chaning to the other player.
        mov 22.(sp), -(sp) ; Backing up current steps.
        sub #1, (sp) ; Substract 1 from number of steps.
        jsr pc, getWPRec
        cmp 28.(sp), #1 ; The father is looking for a maximum.
        beq upMax4 ; Father was looking for a maximum.
        ; Father was looking for a minimum.
        cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
        bgt nUpdate4
        mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
        add #12., sp ; Popping all values besides registers backup.
        mov (sp)+, r5
        mov (sp)+, r3
        mov (sp)+, r2
        mov (sp)+, r1
        mov (sp)+, r0
        mov #0, 18.(r2)
        mov #2, (r2)
        mov r2, 12.(sp) ; Updating father src.
        mov r2, 10.(sp) ; Updating father dest.
        add #18., 10.(sp)
        br jRightB

        upMax4:
          cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
          ble nUpdate4
          mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
          add #12., sp ; Popping all values besides registers backup.
          mov (sp)+, r5
          mov (sp)+, r3
          mov (sp)+, r2
          mov (sp)+, r1
          mov (sp)+, r0
          mov #0, 18.(r2)
          mov #2, (r2)
          mov r2, 12.(sp) ; Updating father src.
          mov r2, 10.(sp) ; Updating father dest.
          add #18., 10.(sp)
          br jRightB

        nUpdate4:
          add #12., sp ; Popping all values besides registers backup.
          mov (sp)+, r5
          mov (sp)+, r3
          mov (sp)+, r2
          mov (sp)+, r1
          mov (sp)+, r0
          mov #0, 18.(r2)
          mov #2, (r2)
          br jRightB1 ; Keep on checking legal moves to the right (cannot eat so we don't need to check an eating option).

jRightB1:
  jmp RightB

      ;This method will check an eating option for black pieces to the left.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      EatLB:
            add #1, r3 ; Increasing row index by 1.
            cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
            bgt jRightB1
            add #1, r5 ;Increasing column index by 1.
            cmp r5, #7
            bgt jRightB1 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
            ;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
            cmp 36.(r2), #0 ; Checking if the cell is empty.
            bne jRightB1 ; If the cell is not empty, cannot eat. Check legal moves to the right.

            ; --- BLACK EAT LEFT ---
            ; Making the move of the black player.
            mov #2, 36.(r2) ; Moving black piece to the new place.
            mov #0, 18.(r2) ; Removing eaten piece.
            mov #0, (r2) ; Removing black piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngMin5 ; Changing maximum to minimum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed5

            chngMin5: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed5: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Backing up current steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax5 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt nUpdate5
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, 36.(r2)
              mov #1, 18.(r2)
              mov #2, (r2)
              mov r2, 12.(sp) ; Updating father src.
              mov r2, 10.(sp) ; Updating father dest.
              add #36., 10.(sp)
              br jRightB1

              upMax5:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble nUpdate5
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 36.(r2)
                mov #1, 18.(r2)
                mov #2, (r2)
                mov r2, 12.(sp) ; Updating father src.
                mov r2, 10.(sp) ; Updating father dest.
                add #36., 10.(sp)
                br jRightB1

              nUpdate5:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 36.(r2)
                mov #1, 18.(r2)
                mov #2, (r2)

            ; This method will check legal moves to the right of black pieces.
            ; r2- current cell address.
            ; r3 - temporary row index .
            ; r5 - temporary column index.
      RightB:
             mov r0, r3 ; Putting index of the current row in r3.
             add #1, r3 ; Increasing row index by 1.
             mov r1, r5 ; Putting index of the current column in r5.
             sub #1, r5 ; Decreasing column index by 1.
             cmp r5, #0
             blt jNxtCll3 ; If column index is less than 0, cannot move right, skip to the next cell.
             cmp 14.(r2), #2 ; Checking if the lower left piece is black.
             beq jNxtCll3 ; If the lower left piece is white, cannot move there, skip to the next cell.
             cmp 14.(r2), #1 ; Checking if the lower left piece is white.
             beq EatRB ; If the lower left piece is white, check if the black piece can eat it.

             ; --- BLACK MOVE RIGHT ---
             ; Making the move of the black player.
             mov #2, 14.(r2) ; Moving black piece to the new place.
             mov #0, (r2) ; Removing black piece from the last place it was.

             ; Backing up registers before calling the REC function.
             mov r0, -(sp) ; Backing up r0.
             mov r1, -(sp) ; Backing up r1.
             mov r2, -(sp) ; Backing up r2.
             mov r3, -(sp) ; Backing up r3.
             mov r5, -(sp) ; Backing up r5.

             ; Preparing the arguments for the REC function.
             mov #0, -(sp) ; Allocating source position.
             mov #0, -(sp) ; Allocating destenation position.
             cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
             beq chngMin6 ; Changing maximum to minimum.
             mov #-100., -(sp) ; Miminum was checked in the last call.
             mov #1, -(sp) ; Maximum will be checked.
             br changed6

             jNxtCll3:
               jmp NextCell

             chngMin6: ; Changing maximum to minimum.
             mov #100., -(sp) ; Maximum was checked in the last call.
             mov #-1., -(sp) ; Minimum will be checked.

             changed6: ; Changed maximum\minimum value.
               mov #3, -(sp)
               sub 24.(sp), (sp) ; Chaning to the other player.
               mov 22.(sp), -(sp) ; Backing up current steps.
               sub #1, (sp) ; Substract 1 from number of steps.
               jsr pc, getWPRec
               cmp 28.(sp), #1 ; The father is looking for a maximum.
               beq upMax6 ; Father was looking for a maximum.
               ; Father was looking for a minimum.
               cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
               bgt nUpdate6
               mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
               add #12., sp ; Popping all values besides registers backup.
               mov (sp)+, r5
               mov (sp)+, r3
               mov (sp)+, r2
               mov (sp)+, r1
               mov (sp)+, r0
               mov #0, 14.(r2)
               mov #2, (r2)
               mov r2, 12.(sp) ; Updating father src.
               mov r2, 10.(sp) ; Updating father dest.
               add #14., 10.(sp)
               br jNxtCll3

               upMax6:
                 cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                 ble nUpdate6
                 mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                 add #12., sp ; Popping all values besides registers backup.
                 mov (sp)+, r5
                 mov (sp)+, r3
                 mov (sp)+, r2
                 mov (sp)+, r1
                 mov (sp)+, r0
                 mov #0, 14.(r2)
                 mov #2, (r2)
                 mov r2, 12.(sp) ; Updating father src.
                 mov r2, 10.(sp) ; Updating father dest.
                 add #14., 10.(sp)
                 br jNxtCll3

               nUpdate6:
                 add #12., sp ; Popping all values besides registers backup.
                 mov (sp)+, r5
                 mov (sp)+, r3
                 mov (sp)+, r2
                 mov (sp)+, r1
                 mov (sp)+, r0
                 mov #0, 14.(r2)
                 mov #2, (r2)
                 br jNxtCll3 ;Skip to the next cell (cannot eat so we don't need to check an eating option).


      ; This method will check an eating option for black pieces to the right.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      EatRB:
            sub #1, r5 ; Reducing column index by 1.
            cmp r5, #0
            blt jNxtCll3 ; If column index is less than 0, cannot eat, skip to the next cell.
            add #1, r3 ; Increasing row index by 1.
            cmp r3, #7
            bgt jNxtCll3 ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
            ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
            cmp 28.(r2), #0 ; Checking if the cell is empty.
            bne jNxtCll3 ;If the cell is not empty, cannot eat. Skip to the next cell.



            ; --- BLACK EAT RIGHT ---
            ; Making the move of the black player.
            mov #2, 28.(r2) ; Moving black piece to the new place.
            mov #0, 14.(r2) ; Removing eaten white piece.
            mov #0, (r2) ; Removing black piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20.(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngMin7 ; Changing maximum to minimum.
            ; Changing minimum to maximum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed7

            chngMin7: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed7: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Backing up current steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax7 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt nUpdate7
              ; Updating new wp to father wp.
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, 28.(r2) ; Moving black piece to the previous place.
              mov #1, 14.(r2) ; Removing eaten white piece.
              mov #2, (r2)
              mov r2, 12.(sp) ; Updating father src.
              mov r2, 10.(sp) ; Updating father dest.
              add #28., 10.(sp)
              br jNxtCll4

jNxtCll4:
  jmp NextCell

              upMax7:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble nUpdate7
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 28.(r2) ; Moving black piece to the new place.
                mov #1, 14.(r2) ; Removing eaten white piece.
                mov #2, (r2)
                mov r2, 12.(sp) ; Updating father src.
                mov r2, 10.(sp) ; Updating father dest.
                add #28., 10.(sp)
                br jNxtCll4

              nUpdate7:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 28.(r2) ; Moving black piece to the new place.
                mov #1, 14.(r2) ; Removing eaten white piece.
                mov #2, (r2)
                br jNxtCll4 ; No more moving options, move to the next cell.



                ; This method will count how many vessles from each color are there on the
                ; given board.
                ;
                ; Input:
                ; Label of the beginning of the board - will be stored at 2(sp).
                ;
                ; Output:
                ; Number of white vessels - after rts will be stored at 4(sp).
                ; Number of black vessels - after rts will be stored at 2(sp).
                ;
                ; Notice: after rts 0(sp) will store the label of the board which is usually no
                ; longer needed.
                countWB:
                        mov r0, -(sp) ; Backing up r0. r0 will be used to scan the board.
                        mov r1, -(sp) ; Backing up r1. r1 will be used to count white vessels.
                        mov r2, -(sp) ; Backing up r2. r2 will be used to count black vessels.
                        mov r3, -(sp) ; Backing up r3. r3 will store the end of the board.
                        clr r1
                        clr r2
                        mov 10.(sp), r0 ; r0 = beginning of the board.
                        mov r0, r3 ; r3 = beginning of the board.
                        add #176, r3 ; r3 = end of the board.
                        cntloop:
                                tst (r0) ;
                                beq endloop ; if (r0) is 0 then no player in this cell.
                                cmp (r0), #1
                                bne addBLK
                                inc r1 ; Current cell is white. r1++ .
                                br endloop ; Go to next cell.
                        addBLK:
                                inc r2 ; Current cell is black. r2++ .
                                br endloop ; Go to next cell.

                     endloop:
                             add #2, r0 ; r0 will point to next cell in the board.
                             cmp r0,r3
                             ble cntloop ; if we are still in the board limits - go to cntloop.
                             ; If we got here we finished going through the entire board.
                             mov r1, 14.(sp) ; Writing white counter to stack.
                             mov r2, 12.(sp) ; Writing black counter to stack.
                             mov (sp)+, r3 ; Restoring the value of r3.
                             mov (sp)+, r2 ; Restoring the value of r2.
                             mov (sp)+, r1 ; Restoring the value of r1.
                             mov (sp)+, r0 ; Restoring the value of r0.
                             rts pc





                ;This method checks if a given board is in a winning state for the given player.
                ;Input -
                ; - A number of player to check - will be stored in 4(sp).
                ; - A label of the beggining of the board - will be stored in 6(sp).
                ;Output -
                ; - (-1) if the current player didn't win, 1 if the current player wins - will be stored in 2(sp).
                checkWin:
                tst -(sp) ; Allocating place for number of white pieces.
                tst -(sp) ; Allocating place for number of black pieces.
                mov 12(sp), -(sp) ; Copying board adress to the top of the stack.
                jsr pc, countWB
                tst (sp)+ ; Pop board adress.
                cmp 10(sp), #1 ; Check if the current player is white.
                bne checkb ; Branch to checkb if the current player is black.
                tst (sp) ; Current player is white, checks the number of black pieces.
                beq currWin ; If the number of black pieces is 0 white player wins.
                tst 2(sp) ; Checks the number of white pieces.
                beq noWin ; Current player is white and the number of white pieces is 0, white player loses.
                br not0 ; Both player's number of pieces is not 0.

                checkb: ; The current player is black.
                tst 2(sp) ; Checks if the number of white pieces is 0.
                beq currWin ; Black player wins.
                tst (sp) ; Checks if the number of black pieces is 0.
                beq noWin ; Current player is black and the number of black pieces is 0.

                not0: ; We get here if the number of both player's pieces is not 0.
                mov #1, -(sp) ; Moving number of white player to check number of moves for him.
                mov #0, -(sp) ; Allocating place for number of moves and setting it to 0.
                ; Checking if there is legal moves for the given player.
                jsr pc, moveChk ; Number of legal moves for white player will be at the top of the stack.
                tst (sp) ; Checks if white player has legal moves to make.
                bne hasMoves ; There are still moves to make.
                mov #2, 2(sp) ; Moving number of black player to check number of moves for him.
                jsr pc, moveChk ; Number of legal moves for black player will be at the top of the stack.
                tst (sp) ; Checks if both players has legal moves to make.
                bne hasMoves ; One of the players still has moves to make.
                tst (sp)+ ; Pops number of player's moves.
                tst (sp)+ ; Pops player number.
                cmp #1, 10(sp) ; Checks if the player is the white player.
                bne blackChk ; The player is the black player.
                cmp 2(sp), (sp) ; Checks if number of white pieces is bigger than number of black pieces.
                bgt currWin ; If the number of white pieces is bigger, white player wins.
                br noWin ; If we got here the number of white pieces is not bigger.
                blackChk: ; The current player color is black.
                cmp (sp), 2(sp) ; Checks if number of black pieces is bigger than number of white pieces.
                bgt currWin ; Black player wins.
                br noWin ; Black player lost.

                currWin: ; The current player wins.
                tst (sp)+ ; Pop number of black pieces.
                tst (sp)+ ; Pop number of white pieces.
                mov #1, 2(sp) ; The return value will be 1.
                rts pc

                hasMoves: ; One of the players still has legal moves.
                tst (sp)+ ; Pops number of moves.
                tst (sp)+ ; Pops the number of player.
                noWin: ; The current player is not winning.
                tst (sp)+ ; Pop number of black pieces.
                tst (sp)+ ; Pop number of white pieces.
                mov #-1., 2(sp)
                rts pc



                ;This method checks the number of moves for  a given player.
                ;Input:
                ; - A number of player to check, will be at 2(sp).
                ;Output:
                ; - A number of moves to add to, will be at (sp).
                moveChk:
                ; r0 - Current row index.
                ; r1 - Current column index.
                mov r0, -(sp) ; Saving r0's value on stack.
                mov r1, -(sp) ; Saving r1's value on stack.
                mov r2, -(sp) ; Saving r2's value on stack
                mov r3, -(sp) ; Saving r3's value on stack
                mov r5, -(sp); Saving r5's value on stack
                clr r0 ; Sets r0 to 0.
                clr r1 ; Sets r1 to 0.
                cmp 14.(sp), #1 ; Checking if the current color is white.
                bne Black1 ; If the color is not white, branch to Black.
                br White1 ; If the color is white, branch to White.



                White1:
                ; This method will check legal moves of all white pieces and add 1 to NumMoves each time a legal move is found.
                ; r2- current cell pointer.
                ; r3 - temporary row index (will be used once for another calculation).
                ; r5 - temporary column index (will be used once for another calculation).

                mov r0, r3  ; Putting index of the current row in r3.
                mov r1, r5  ; Putting index of the current column in r5.
                mov #Board, r2 ; Putting board array starting index in r2.
                mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bits).
                mul #2, r5 ; Multiplying the number of column by 2 (decimal) (length of each column in bits).
                add r3, r2 ; Adding the number of bits needed in order to point to a start of a row.
                add r5, r2 ; Adding the number of bits needed in order to point a cell in a row.
                ; r2 will now contain the address of the current cell.
                cmp (r2), #1 ; Checking if the current piece is white.
                bne skipcell1 ; If the color of the current piece is not white skip to the next cell.
                mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
                sub #1, r3 ; Reducing row index by 1.
                cmp r3, #0
                blt skipcell1 ; If row index is less than 0, cannot move left or right, skip to the next cell.
                mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
                add #1, r5 ; Increasing column index by 1.
                cmp r5, #7
                bgt jLeftW01 ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
                cmp -14.(r2), #1 ; Checking if the upper right piece is white.
                beq jLeftW01 ; If the upper right piece is white, cannot go there, check legal moves to the left.
                cmp -14.(r2), #2 ; Checking if the upper right piece is black.
                beq eatrw1 ; If the upper right piece is black, check if the white piece can eat it.
                add #1, 12.(sp) ; If we got here the upper right cell contains 0, the white piece can move there. Adding 1 to number of legal moves.
                br End1 ;Found a legal move.


                eatrw1:
                ;This method will check an eating option the right of white pieces.
                ; r2- current cell pointer.
                ; r3 - temporary row index .
                ; r5 - temporary column index.

                sub #1, r3 ; Reducing row index by 1.
                cmp r3, #0
                blt jLeftW01 ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
                add #1, r5 ;Increasing column index by 1.
                cmp r5, #7
                bgt jLeftW01 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
                ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
                cmp -28.(r2), #0 ; Checking if the cell is empty.
                bne jLeftW01 ; If the cell is not empty, cannot eat. Check legal moves to the left.
                add #1, 12.(sp) ;If we got here, can eat, adding 1 to number of legal moves.
                br End1 ;Found a legal move.


                jLeftW01:
                 ; This method will check legal moves to the left of white pieces.
                 ; r2- current cell pointer.
                 ; r3 - temporary row index .
                 ; r5 - temporary column index.

                mov r0, r3 ; Putting index of the current row in r3.
                sub #1, r3 ; Reducing row index by 1.
                mov r1, r5 ; Putting index of the current column in r5.
                sub #1, r5 ; Reducing column index by 1.
                cmp r5, #0
                blt skipcell1 ; If column index is less than 0, cannot move right, skip to the next cell.
                cmp -18.(r2), #1 ; Checking if the upper left piece is white.
                beq skipcell1 ; If the upper left piece is white, cannot move there, skip to the next cell.
                cmp -18.(r2), #2 ; Checking if the upper left piece is black.
                beq eatlw1 ; If the upper left piece is black, Check if the white piece can eat it.
                add #1, 12.(sp) ; If we got here, upper left cell contains 0, can move there. Adding 1 to number of legal moves..
                br End1 ;Found a legal move.

                eatlw1:
                ;This method will check an eating option the left of white pieces.
                ; r2- current cell pointer.
                ; r3 - temporary row index .
                ; r5 - temporary column index.

                sub #1, r5 ; Reducing column index by 1.
                cmp r5, #0
                blt skipcell1 ; If column index is less than 0, cannot eat, skip to the next cell.
                sub #1, r3 ; Reducing row index by 1.
                cmp r3, #0
                blt skipcell1 ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
                ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
                cmp -36.(r2), #0 ; Checking if the cell is empty.
                bne skipcell1 ;If the cell is not empty, cannot eat. Skip to the next cell.
                add #1, 12.(sp) ;If we got here, can eat, adding 1 to legal number of moves on the stack.
                br End1 ;Found a legal move.

                End1: ;If we got here we checked all the cells of the array or we got a legal move.
                mov (sp)+, r5 ; Returning r5 it's original value.
                mov (sp)+, r3 ; Returning r3 it's original value.
                mov (sp)+, r2 ; Returning r2 it's original value.
                mov (sp)+, r1 ; Returning r1 it's original value.
                mov (sp)+, r0 ; Returning r0 it's original value.
                rts pc ; When we return from this subroutine the output will be at the top of the stack

                skipcell1:
                ; This method will skip to the next cell by adding 1 to column index. If column
                ; index is bigger than 7 sets it to 0 and adds 1 to row index.
                ; r0 - Current row index.
                ; r1 - Current column index.

                add #1, r1
                cmp r1, #8 ; Checking if passed end of row.
                blt inRange1 ; Index of column is legal.
                clr r1 ; If we got here index of column passed end of row. Set it to 0.
                add #1, r0 ; Go to the next row.
                cmp r0, #7
                bgt End1 ; If index of row is bigger than 7 we reached the end of the board.

                inRange1:
                ;Continue on checking in the same row.
                cmp 14.(sp), #1
                bne Black1
                br White1


                Black1:
                ;This method will check legal moves of all black pieces and add 1 to NumMoves each time a legal move is found.
                ; r2- current cell pointer.
                ; r3 - temporary row index (will be used once for another calculation).
                ; r5 - temporary column index (will be used once for another calculation).

                mov r0, r3  ; Putting index of the current row in r3.
                mov r1, r5  ; Putting index of the current column in r5.
                mov #Board, r2 ; Putting board array starting index in r2.
                mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bits).
                mul #2, r5 ; Multiplying the number of column by 2 (decimal) (length of each column in bits).
                add r3, r2 ;Adding the number of bits needed in order to point to a start of a row.
                add r5, r2 ; Adding the number of bits needed in order to point a cell in a row.
                ; r2 will now contain the address of the current cell.
                cmp (r2), #2 ; Checking if the current piece is black.
                bne skipcell1 ; If the color of the current piece is not black skip to the next cell.
                mov r0, r3 ; Putting index of the current row in r3.
                add #1, r3 ; Increasing row index by 1.
                cmp r3, #7
                bgt skipcell1 ; If row index is bigger than 7, cannot move left, skip to the next cell.
                mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
                add #1, r5 ; Increasing column index by 1.
                cmp r5, #7
                bgt RightB1 ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
                cmp 18.(r2), #2 ; Checking if the lower right piece is black.
                beq RightB1 ; If the lower right piece is black, cannot go there, Check legal moves to the right.
                cmp 18.(r2), #1 ; Checking if the lower right piece is black.
                beq eatlb1 ; If the lower right piece is white, check if the black piece can eat it.
                add #1, 12.(sp) ; If we got here the lower right cell contains 0, the black piece can move there. Adding 1 to number of legal moves.
                br End1 ;Found a legal move.

                eatlb1:
                ;This method will check an eating option the left of black pieces.
                ; r2- current cell pointer.
                ; r3 - temporary row index .
                ; r5 - temporary column index.

                add #1, r3 ; Increasing row index by 1.
                cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
                bgt RightB1
                add #1, r5 ;Increasing column index by 1.
                cmp r5, #7
                bgt RightB1 ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
                ;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
                cmp 36.(r2), #0 ; Checking if the cell is empty.
                bne RightB1 ; If the cell is not empty, cannot eat. Check legal moves to the right.
                add #1, 12.(sp) ;If we got here, can eat. Adding 1 to number of legal moves.
                br End1 ;Found a legal move.

                RightB1:
                ; This method will check legal moves to the right of black pieces.
                ; r2- current cell pointer.
                ; r3 - temporary row index .
                ; r5 - temporary column index.

                mov r0, r3 ; Putting index of the current row in r3.
                add #1, r3 ; Increasing row index by 1.
                mov r1, r5 ; Putting index of the current column in r5.
                sub #1, r5 ; Decreasing column index by 1.
                cmp r5, #0
                blt skipcell1 ; If column index is less than 0, cannot move right, skip to the next cell.
                cmp 14.(r2), #2 ; Checking if the lower left piece is black.
                beq skipcell1 ; If the lower left piece is white, cannot move there, skip to the next cell.
                cmp 14.(r2), #1 ; Checking if the lower left piece is white.
                beq eatrb1 ; If the lower left piece is white, check if the black piece can eat it.
                add #1, 12.(sp) ; If we got here the lower left cell contains 0, the black piece can move there. Adding 1 to number of legal moves.
                br End1 ;Found a legal move.


                eatrb1:
                ; This method will check an eating option the right of black pieces.
                ; r2- current cell pointer.
                ; r3 - temporary row index .
                ; r5 - temporary column index.

                sub #1, r5 ; Reducing column index by 1.
                cmp r5, #0
                blt skipcell1 ; If column index is less than 0, cannot eat, skip to the next cell.
                add #1, r3 ; Increasing row index by 1.
                cmp r3, #7
                bgt skipcell1 ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
                ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
                cmp 28.(r2), #0 ; Checking if the cell is empty.
                bne skipcell1 ;If the cell is not empty, cannot eat. Skip to the next cell.
                add #1, 12.(sp) ;If we got here, can eat. Adding 1 to number of legal moves.
                br End1 ;Found a legal move.

                ; Input:
                ; 1. Label of the current board status - will be stored at 4(sp).
                ; 2. Current player's turn (1-white,2-black) - will be stored at 2(sp).
                ; Output:
                ; Winning parameter - will be stored at R4.
                  calcWP:
                         mov 0, -(sp) ; Leaving blank space for output.
                         mov 0, -(sp) ; Leaving blank space for output.
                         mov 8(sp), -(sp) ; Giving the label of the board as input.
                         jsr pc, countWB ; Counter number of vessels from each color.
                         add #2, sp ; Popping the no longer needed board label from stack.
                         cmp 6(sp), #1
                         beq WPforW ; if current player (input) is white - go to WPforW
                         ; If we got here then the current player is black. It means that
                         ; the last player to move was white.
                         mov 2(sp), r4 ; r4 = number of white vessels.
                         sub (sp), r4 ; r4 = r4 - number of black vessels.
                         br endCalWP ; Jumping to the end of the method.
                         WPforW:
                                ; If we got here current player is white. It means that the
                                ; last player to move was black.
                                mov (sp), r4 ; r4 = number of black vessels.
                                sub 2(sp), r4 ; r4 = r4 - number of white players.
                                br endCalWP ; Jumping to the end of the method.
                endCalWP:
                         add #4, sp ; popping 2 items from stack (counters of W&B vessles)
                         rts pc


.=torg+7000

Board:
.word 0, 0, 0, 0, 0, 2, 0, 0
.word 0, 0, 0, 0, 1, 0, 0, 0
.word 0, 0, 0, 0, 0, 0, 0, 0
.word 0, 0, 0, 0, 0, 0, 0, 0
.word 0, 0, 0, 0, 0, 0, 0, 0
.word 0, 0, 0, 0, 0, 0, 0, 0
.word 0, 0, 0, 0, 0, 0, 0, 0
.word 0, 0, 0, 0, 0, 0, 0, 0
Player: .word 2
Steps: .word 1
WP: .word 0
SrcPos: .word 0
DstPos: .word 0
