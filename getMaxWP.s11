


getMaxWP:
  mov #0, -(sp) ; Allocating source position.
  mov #0, -(sp) ; Allocating destenation position.
  mov #-100., -(sp) ; Allocating place for WP.
  mov #1, -(sp) ;  Maximum for the first player.
  mov Player, -(sp) ; Moving the player we check for to the stack.
  mov Steps, -(sp) ; Moving number of steps to stack.
  jsr pc, getWPRec
  add #6, sp
  mov (sp)+, @8.(sp) ; Writing the best wp to WinParam label.
  sub #5000. (sp) ;
  mov r0, -(sp)
  mov r1, -(sp)
  clr r0
  mov 4(sp), r1
  div #2, r1
  mov r0, @12.(sp)
  clr r0
  sub #5000., 6(sp)
  mov 6(sp), r1
  div #2, r1
  mov r0, @14.(sp)
  mov (sp)+, r1
  mov (sp)+, r0
  add #4, sp
  rts pc



getWPRec:
 ; --- STOP TERMS ---
 ; Preparing to call for checkWin with the previous player (last player to move).
 mov #Board, -(sp) ; Moving board adress to stack.
 mov 6(sp), -(sp) ; Moving current player to the top of the stack.
 mov r0, -(sp) ; Backing up r0.
 mov #3, r0
 sub 2(sp), r0 ; Substract number of player from 3 will give us the other player.
 mov r0, 2(sp) ; 2(sp) will now be the current player and the value of (sp) will be used by checkWin.
 mov (sp), r0 ; Restoring r0's value.
 jsr pc, checkWin ; CheckWin will use the place allocted for r0 in the stack for output.
 cmp #1, (sp)+ ; Pop the return value of checkWin and check which player won.
 beq whoWon
 add #4, (sp) ; Pop the other player and board from the stack.
 tst 2(sp) ; Check if the current number of steps is 0.
 bne chkMoves
 ; We get here in case steps is 0.
 mov #Board, -(sp) ; Moving board adress to stack.
 mov 6(sp), -(sp) ; Moving current player to the top of the stack.
 jsr pc, calcWP
 add #4, sp
 mov r4, 8.(sp) ; Copying calculated wp from r4 to the fathers wp.
 rts pc

 whoWon:
   cmp (sp)+, Player ; Check if the current player is the same as found in label Player.
   bne playerLos
   mov #20., 10.(sp)
   tst (sp)+
   rts pc
   playerLos:
     mov #-20., 6(sp)
     add #4, sp
     rts pc
; --- END OF STOP TERMS ---



     ; r0 - Current row index.
     ; r1 - Current column index.
     chkMoves:
           clr r0 ; Sets r0 to 0.
           clr r1 ; Sets r1 to 0.
           cmp 4(sp), #1 ; Checking if the current color is white.
           bne Black ; If the color is not white, branch to Black.
           br White ; If the color is white, branch to White.



; This method will check legal moves of all white pieces and add 1 to NumMoves each time a legal move is found.
; r2- current cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
White:
      mov r0, r3  ; Putting index of the current row in r3.
      mov r1, r5  ; Putting index of the current column in r5.
      mov #Board, r2 ; Putting board array starting index in r2.
      mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
      mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
      add r3, r2 ; Adding the number of bytes needed in order to point to the beginning of a row.
      add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
      ; r2 will now contain the address of the current cell.
      cmp (r2), #1 ; Checking if the current piece is white.
      bne NextCell ; If the color of the current piece is not white skip to the next cell.
      mov r0, r3 ; Setting r3 to the current row index (after changing it earlier).
      sub #1, r3 ; Reducing row index by 1.
      cmp r3, #0
      blt NextCell ; If row index is less than 0, cannot move at all, skip to the next cell.
      mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
      add #1, r5 ; Increasing column index by 1.
      cmp r5, #7
      bgt LeftW ; If column index is bigger than 7, the current piece cannot move right, check legal moves to the left.
      cmp -14.(r2), #1 ; Checking if the upper right piece is white.
      beq LeftW ; If the upper right piece is white, cannot go there, check legal moves to the left.
      cmp -14.(r2), #2 ; Checking if the upper right piece is black.
      beq EatRW ; If the upper right piece is black, check if the white piece can eat it.

      ; --- WHITE MOVE RIGHT ---
      ; Making the move of the white player.
      mov #1, -14.(r2) ; Moving white piece to the new place.
      mov #0, (r2) ; Removing white piece from the last place it was.

      ; Backing up registers before calling the REC function.
      mov r0, -(sp) ; Backing up r0.
      mov r1, -(sp) ; Backing up r1.
      mov r2, -(sp) ; Backing up r2.
      mov r3, -(sp) ; Backing up r3.
      mov r5, -(sp) ; Backing up r5.

      ; Preparing the arguments for the REC function.
      mov #0, -(sp) ; Allocating source position.
      mov #0, -(sp) ; Allocating destenation position.
      cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
      beq chngeMin0 ; Changing maximum to minimum.
      mov #-100., -(sp) ; Miminum was checked in the last call.
      mov #1, -(sp) ; Maximum will be checked.
      br changed0

      chngeMin0: ; Changing maximum to minimum.
      mov #100., -(sp) ; Maximum was checked in the last call.
      mov #-1., -(sp) ; Minimum will be checked.

      changed0: ; Changed maximum\minimum value.
        mov #3, -(sp)
        sub 24.(sp), (sp) ; Chaning to the other player.
        mov 22.(sp), -(sp) ; Copying last number of steps.
        sub #1, (sp) ; Substract 1 from number of steps.
        jsr pc, getWPRec
        cmp 28.(sp), #1 ; The father is looking for a maximum.
        beq upMax0 ; Father was looking for a maximum.
        ; Father was looking for a minimum.
        cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
        bgt noUpdate0
        ;Updating father wp , src and dest.
        mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
        add #12., sp ; Popping all values besides registers backup.
        mov (sp)+, r5
        mov (sp)+, r3
        mov (sp)+, r2
        mov (sp)+, r1
        mov (sp)+, r0
        mov #0, -14.(r2) ; Moving white piece to the previous place.
        mov #1, (r2)
        mov r2, 12.(sp) ; Updating father src.
        mov -14.(r2), 10.(sp) ; Updating father dest.
        br LeftW

        upMax0:
          cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
          ble noUpdate0
          mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
          add #12., sp ; Popping all values besides registers backup.
          mov (sp)+, r5
          mov (sp)+, r3
          mov (sp)+, r2
          mov (sp)+, r1
          mov (sp)+, r0
          mov #0, -14.(r2) ; Moving white piece to the previous place.
          mov #1, (r2)
          mov r2, 12.(sp) ; Updating father src.
          mov -14.(r2), 10.(sp) ; Updating father dest.
          br LeftW

        noUpdate0:
          add #12., (sp) ; Popping all values besides registers backup.
          mov (sp)+, r5
          mov (sp)+, r3
          mov (sp)+, r2
          mov (sp)+, r1
          mov (sp)+, r0
          mov #0, -14.(r2) ; Moving white piece to the previous place.
          mov #1, (r2)
          br LeftW ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).

      ;This method will check an eating option for white pieces to the right.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      EatRW:
            sub #1, r3 ; Reducing row index by 1.
            cmp r3, #0
            blt LeftW ; If r3 is less than 0, cannot eat (out of bounds). Check legal moves to the left.
            add #1, r5 ;Increasing column index by 1.
            cmp r5, #7
            bgt LeftW ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the left.
            ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, we need to check if it is empty.
            cmp -28.(r2), #0 ; Checking if the cell is empty.
            bne LeftW ; If the cell is not empty, cannot eat. Check legal moves to the left.

            ; --- WHITE EAT RIGHT ---
            ; Making the move of the white player.
            mov #1, -28.(r2) ; Moving white piece to the new place.
            mov #0, -14.(r2) ; Removing eaten piece.
            mov #0, (r2) ; Removing white piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngeMin1 ; Changing maximum to minimum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed1

            chngeMin1: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed1: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Copying last number of steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax1 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt noUpdate1
              ;Updating father wp , src and dest.
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, -28.(r2) ; Moving white piece to the new place.
              mov #2, -14.(r2) ; Removing eaten piece.
              mov #1, (r2) ; Removing white piece from the last place it was.
              mov r2, 12.(sp) ; Updating father src.
              mov -28.(r2), 10.(sp) ; Updating father dest.
              br LeftW

              upMax1:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble noUpdate0
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, -28.(r2) ; Moving white piece to the new place.
                mov #2, -14.(r2) ; Removing eaten piece.
                mov #1, (r2) ; Removing white piece from the last place it was.
                mov r2, 12.(sp) ; Updating father src.
                mov -28.(r2), 10.(sp) ; Updating father dest.
                br LeftW

              noUpdate1:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, -28.(r2) ; Moving white piece to the new place.
                mov #2, -14.(r2) ; Removing eaten piece.
                mov #1, (r2) ; Removing white piece from the last place it was.
                br LeftW ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).


      ; This method will check legal moves of white pieces to the left.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      LeftW:
            mov r0, r3 ; Putting index of the current row in r3.
            sub #1, r3 ; Reducing row index by 1.
            mov r1, r5 ; Putting index of the current column in r5.
            sub #1, r5 ; Reducing column index by 1.
            cmp r5, #0
            blt NextCell ; If column index is less than 0, cannot move right, skip to the next cell.
            cmp -18.(r2), #1 ; Checking if the upper left piece is white.
            beq NextCell ; If the upper left piece is white, cannot move there, skip to the next cell.
            cmp -18.(r2), #2 ; Checking if the upper left piece is black.
            beq EatLW ; If the upper left piece is black, Check if the white piece can eat it.

            ; --- WHITE MOVE LEFT ---
            ; Making the move of the white player.
            mov #1, -18.(r2) ; Moving white piece to the new place.
            mov #0, (r2) ; Removing white piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngeMin2 ; Changing maximum to minimum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed2

            chngeMin2: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed2: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Copying last number of steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax2 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt noUpdate2
              ;Updating father wp , src and dest.
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, -18.(r2) ; Moving white piece to the previous place.
              mov #1, (r2)
              mov r2, 12.(sp) ; Updating father src.
              mov -18.(r2), 10.(sp) ; Updating father dest.
              br NextCell

              upMax0:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble noUpdate0
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, -18.(r2) ; Moving white piece to the previous place.
                mov #1, (r2)
                mov r2, 12.(sp) ; Updating father src.
                mov -18.(r2), 10.(sp) ; Updating father dest.
                br NextCell

              noUpdate0:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, -18.(r2) ; Moving white piece to the previous place.
                mov #1, (r2)
                br NextCell ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).


      ;This method will check an eating option for white pieces to the left.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      EatLW:
            sub #1, r5 ; Reducing column index by 1.
            cmp r5, #0
            blt NextCell ; If column index is less than 0, cannot eat, skip to the next cell.
            sub #1, r3 ; Reducing row index by 1.
            cmp r3, #0
            blt NextCell ; If r3 is less than 0, cannot eat (out of bounds). Skip to the next cell.
            ;If we got here, the cell which the current white piece should be
            ;placed in after eating is in the board bounds, Check if it is empty.
            cmp -36.(r2), #0 ; Checking if the cell is empty.
            bne NextCell ;If the cell is not empty, cannot eat. Skip to the next cell.

            ; --- WHITE EAT LEFT ---
            ; Making the move of the white player.
            mov #1, -36.(r2) ; Moving white piece to the new place.
            mov #0, -18.(r2) ; Removing eaten piece.
            mov #0, (r2) ; Removing white piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngeMin3 ; Changing maximum to minimum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed3

            chngeMin3: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed3: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Copying last number of steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax3 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt noUpdate3
              ;Updating father wp , src and dest.
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, -36.(r2) ; Moving white piece to the previous place.
              mov #2, -18.(r2)
              mov #1, (r2)
              mov r2, 12.(sp) ; Updating father src.
              mov -36.(r2), 10.(sp) ; Updating father dest.
              br NextCell

              upMax3:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble noUpdate3
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, -36.(r2) ; Moving white piece to the previous place.
                mov #2, -18.(r2)
                mov #1, (r2)
                mov r2, 12.(sp) ; Updating father src.
                mov -36.(r2), 10.(sp) ; Updating father dest.
                br NextCell

              noUpdate0:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, -36.(r2) ; Moving white piece to the previous place.
                mov #2, -18.(r2)
                mov #1, (r2)
                br NextCell ; Keep on checking legal moves to the left (cannot eat so we don't need to check an eating option).


            End: ;If we got here we checked all the cells of the array.
            rts pc


            ; This method will skip to the next cell by adding 1 to column index. If column
            ; index is bigger than 7 sets it to 0 and adds 1 to row index.
            ; r0 - Current row index.
            ; r1 - Current column index.
            NextCell:
                     add #1, r1 ; Increasing column index by 1.
                     cmp r1, #8 ; Checking if reached the end of the row.
                     blt InRange ; Branch to InRange if the index of column is legal.
                     clr r1 ; If we got here index of column reached the end of row. Sets it to 0.
                     add #1, r0 ; Go to the next row.
                     cmp r0, #7
                     bgt End ; If index of row is bigger than 7 we reached the end of the board.

                     ;Continues to the next cell once its indexes are valid.
                     InRange:
                             cmp 4(sp), #1
                             bne Black
                             br White


;This method will check legal moves of all black pieces and add 1 to NumMoves
;each time a legal move is found.
; r2- current cell address.
; r3 - temporary row index (will be used once for another calculation).
; r5 - temporary column index (will be used once for another calculation).
Black:
      mov r0, r3  ; Putting index of the current row in r3.
      mov r1, r5  ; Putting index of the current column in r5.
      mov #Board, r2 ; Putting board array starting index in r2.
      mul #16., r3 ; Multiplying the number of row by 16 (decimal) (length of each row in bytes).
      mul #2, r5 ; Multiplying the number of column by 2 (decimal) (width of each column in bytes).
      add r3, r2 ;Adding the number of bytes needed in order to point to the beginning of a row.
      add r5, r2 ; Adding the number of bytes needed in order to point a cell in a row.
      ; r2 will now contain the address of the current cell.
      cmp (r2), #2 ; Checking if the current piece is black.
      bne NextCell ; If the color of the current piece is not black skip to the next cell.
      mov r0, r3 ; Putting index of the current row in r3.
      add #1, r3 ; Increasing row index by 1.
      cmp r3, #7
      bgt NextCell ; If row index is bigger than 7, cannot move at all, skip to the next cell.
      mov r1, r5 ; Setting r5 to the current column index (after changing it eariler).
      add #1, r5 ; Increasing column index by 1.
      cmp r5, #7
      bgt RightB ; If column index is bigger than 7, the current piece cannot move left, Check legal moves to the right.
      cmp 18.(r2), #2 ; Checking if the lower right piece is black.
      beq RightB ; If the lower left piece is black, cannot go there, Check legal moves to the right.
      cmp 18.(r2), #1 ; Checking if the lower right piece is black.
      beq EatLB ; If the lower right piece is white, check if the black piece can eat it.


      ; --- BLACK MOVE LEFT ---
      ; Making the move of the black player.
      mov #2, 18.(r2) ; Moving black piece to the new place.
      mov #0, (r2) ; Removing black piece from the last place it was.

      ; Backing up registers before calling the REC function.
      mov r0, -(sp) ; Backing up r0.
      mov r1, -(sp) ; Backing up r1.
      mov r2, -(sp) ; Backing up r2.
      mov r3, -(sp) ; Backing up r3.
      mov r5, -(sp) ; Backing up r5.

      ; Preparing the arguments for the REC function.
      mov #0, -(sp) ; Allocating source position.
      mov #0, -(sp) ; Allocating destenation position.
      cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
      beq chngeMin4 ; Changing maximum to minimum.
      mov #-100., -(sp) ; Miminum was checked in the last call.
      mov #1, -(sp) ; Maximum will be checked.
      br changed4

      chngeMin4: ; Changing maximum to minimum.
      mov #100., -(sp) ; Maximum was checked in the last call.
      mov #-1., -(sp) ; Minimum will be checked.

      changed4: ; Changed maximum\minimum value.
        mov #3, -(sp)
        sub 24.(sp), (sp) ; Chaning to the other player.
        mov 22.(sp), -(sp) ; Backing up current steps.
        sub #1, (sp) ; Substract 1 from number of steps.
        jsr pc, getWPRec
        cmp 28.(sp), #1 ; The father is looking for a maximum.
        beq upMax4 ; Father was looking for a maximum.
        ; Father was looking for a minimum.
        cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
        bgt noUpdate4
        mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
        add #12., sp ; Popping all values besides registers backup.
        mov (sp)+, r5
        mov (sp)+, r3
        mov (sp)+, r2
        mov (sp)+, r1
        mov (sp)+, r0
        mov #0, 18.(r2)
        mov #2, (r2)
        mov r2, 12.(sp) ; Updating father src.
        mov 18.(r2), 10.(sp) ; Updating father dest.
        br RightB

        upMax4:
          cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
          ble noUpdate4
          mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
          add #12., sp ; Popping all values besides registers backup.
          mov (sp)+, r5
          mov (sp)+, r3
          mov (sp)+, r2
          mov (sp)+, r1
          mov (sp)+, r0
          mov #0, 18.(r2)
          mov #2, (r2)
          mov r2, 12.(sp) ; Updating father src.
          mov 18.(r2), 10.(sp) ; Updating father dest.
          br RightB

        noUpdate4:
          add #12., sp ; Popping all values besides registers backup.
          mov (sp)+, r5
          mov (sp)+, r3
          mov (sp)+, r2
          mov (sp)+, r1
          mov (sp)+, r0
          mov #0, 18.(r2)
          mov #2, (r2)
          br RightB ; Keep on checking legal moves to the right (cannot eat so we don't need to check an eating option).


      ;This method will check an eating option for black pieces to the left.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      EatLB:
            add #1, r3 ; Increasing row index by 1.
            cmp r3, #7 ; If r3 is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
            bgt RightB
            add #1, r5 ;Increasing column index by 1.
            cmp r5, #7
            bgt RightB ; If column index is bigger than 7, cannot eat (out of bounds). Check legal moves to the right.
            ;If we got here, the cell which the current black piece should be placed after eating is in the board bounds, we need to check if it is empty.
            cmp 36.(r2), #0 ; Checking if the cell is empty.
            bne RightB ; If the cell is not empty, cannot eat. Check legal moves to the right.

            ; --- BLACK EAT LEFT ---
            ; Making the move of the black player.
            mov #2, 36.(r2) ; Moving black piece to the new place.
            mov #0, 18.(r2) ; Removing eaten piece.
            mov #0, (r2) ; Removing black piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngeMin5 ; Changing maximum to minimum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed5

            chngeMin5: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed5: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Backing up current steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax5 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt noUpdate5
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, 36.(r2)
              mov #1, 18.(r2)
              mov #2, (r2)
              mov r2, 12.(sp) ; Updating father src.
              mov 36.(r2), 10.(sp) ; Updating father dest.
              br RightB

              upMax5:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble noUpdate5
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 36.(r2)
                mov #1, 18.(r2)
                mov #2, (r2)
                mov r2, 12.(sp) ; Updating father src.
                mov 36.(r2), 10.(sp) ; Updating father dest.
                br RightB

              noUpdate5:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 36.(r2)
                mov #1, 18.(r2)
                mov #2, (r2)

            ; This method will check legal moves to the right of black pieces.
            ; r2- current cell address.
            ; r3 - temporary row index .
            ; r5 - temporary column index.
      RightB:
             mov r0, r3 ; Putting index of the current row in r3.
             add #1, r3 ; Increasing row index by 1.
             mov r1, r5 ; Putting index of the current column in r5.
             sub #1, r5 ; Decreasing column index by 1.
             cmp r5, #0
             blt NextCell ; If column index is less than 0, cannot move right, skip to the next cell.
             cmp 14.(r2), #2 ; Checking if the lower left piece is black.
             beq NextCell ; If the lower left piece is white, cannot move there, skip to the next cell.
             cmp 14.(r2), #1 ; Checking if the lower left piece is white.
             beq EatRB ; If the lower left piece is white, check if the black piece can eat it.

             ; --- BLACK MOVE RIGHT ---
             ; Making the move of the black player.
             mov #2, 14.(r2) ; Moving black piece to the new place.
             mov #0, (r2) ; Removing black piece from the last place it was.

             ; Backing up registers before calling the REC function.
             mov r0, -(sp) ; Backing up r0.
             mov r1, -(sp) ; Backing up r1.
             mov r2, -(sp) ; Backing up r2.
             mov r3, -(sp) ; Backing up r3.
             mov r5, -(sp) ; Backing up r5.

             ; Preparing the arguments for the REC function.
             mov #0, -(sp) ; Allocating source position.
             mov #0, -(sp) ; Allocating destenation position.
             cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
             beq chngeMin6 ; Changing maximum to minimum.
             mov #-100., -(sp) ; Miminum was checked in the last call.
             mov #1, -(sp) ; Maximum will be checked.
             br changed6

             chngeMin6: ; Changing maximum to minimum.
             mov #100., -(sp) ; Maximum was checked in the last call.
             mov #-1., -(sp) ; Minimum will be checked.

             changed6: ; Changed maximum\minimum value.
               mov #3, -(sp)
               sub 24.(sp), (sp) ; Chaning to the other player.
               mov 22.(sp), -(sp) ; Backing up current steps.
               sub #1, (sp) ; Substract 1 from number of steps.
               jsr pc, getWPRec
               cmp 28.(sp), #1 ; The father is looking for a maximum.
               beq upMax6 ; Father was looking for a maximum.
               ; Father was looking for a minimum.
               cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
               bgt noUpdate6
               mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
               add #12., sp ; Popping all values besides registers backup.
               mov (sp)+, r5
               mov (sp)+, r3
               mov (sp)+, r2
               mov (sp)+, r1
               mov (sp)+, r0
               mov #0, 14.(r2)
               mov #2, (r2)
               mov r2, 12.(sp) ; Updating father src.
               mov 14.(r2), 10.(sp) ; Updating father dest.
               br NextCell

               upMax6:
                 cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                 ble noUpdate6
                 mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                 add #12., sp ; Popping all values besides registers backup.
                 mov (sp)+, r5
                 mov (sp)+, r3
                 mov (sp)+, r2
                 mov (sp)+, r1
                 mov (sp)+, r0
                 mov #0, 14.(r2)
                 mov #2, (r2)
                 mov r2, 12.(sp) ; Updating father src.
                 mov 14.(r2), 10.(sp) ; Updating father dest.
                 br NextCell

               noUpdate6:
                 add #12., sp ; Popping all values besides registers backup.
                 mov (sp)+, r5
                 mov (sp)+, r3
                 mov (sp)+, r2
                 mov (sp)+, r1
                 mov (sp)+, r0
                 mov #0, 14.(r2)
                 mov #2, (r2)
                 br NextCell ;Skip to the next cell (cannot eat so we don't need to check an eating option).


      ; This method will check an eating option for black pieces to the right.
      ; r2- current cell address.
      ; r3 - temporary row index .
      ; r5 - temporary column index.
      EatRB:
            sub #1, r5 ; Reducing column index by 1.
            cmp r5, #0
            blt NextCell ; If column index is less than 0, cannot eat, skip to the next cell.
            add #1, r3 ; Increasing row index by 1.
            cmp r3, #7
            bgt NextCell ; If r3 is bigger than 7, cannot eat (out of bounds). Skip to the next cell.
            ;If we got here, the cell which the current white piece should be placed after eating is in the board bounds, Check if it is empty.
            cmp 28.(r2), #0 ; Checking if the cell is empty.
            bne NextCell ;If the cell is not empty, cannot eat. Skip to the next cell.



            ; --- BLACK EAT RIGHT ---
            ; Making the move of the black player.
            mov #2, 28.(r2) ; Moving black piece to the new place.
            mov #0, 14.(r2) ; Removing eaten white piece.
            mov #0, (r2) ; Removing black piece from the last place it was.

            ; Backing up registers before calling the REC function.
            mov r0, -(sp) ; Backing up r0.
            mov r1, -(sp) ; Backing up r1.
            mov r2, -(sp) ; Backing up r2.
            mov r3, -(sp) ; Backing up r3.
            mov r5, -(sp) ; Backing up r5.

            ; Preparing the arguments for the REC function.
            mov #0, -(sp) ; Allocating source position.
            mov #0, -(sp) ; Allocating destenation position.
            cmp #1, 20(sp) ; Checking if minimum or maximum was checked in the last call.
            beq chngeMin7 ; Changing maximum to minimum.
            ; Changing minimum to maximum.
            mov #-100., -(sp) ; Miminum was checked in the last call.
            mov #1, -(sp) ; Maximum will be checked.
            br changed7

            chngeMin7: ; Changing maximum to minimum.
            mov #100., -(sp) ; Maximum was checked in the last call.
            mov #-1., -(sp) ; Minimum will be checked.

            changed7: ; Changed maximum\minimum value.
              mov #3, -(sp)
              sub 24.(sp), (sp) ; Chaning to the other player.
              mov 22.(sp), -(sp) ; Backing up current steps.
              sub #1, (sp) ; Substract 1 from number of steps.
              jsr pc, getWPRec
              cmp 28.(sp), #1 ; The father is looking for a maximum.
              beq upMax7 ; Father was looking for a maximum.
              ; Father was looking for a minimum.
              cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
              bgt noUpdate7
              ; Updating new wp to father wp.
              mov 6(sp), 30.(sp) ; Updating father wp to new minimum.
              add #12., sp ; Popping all values besides registers backup.
              mov (sp)+, r5
              mov (sp)+, r3
              mov (sp)+, r2
              mov (sp)+, r1
              mov (sp)+, r0
              mov #0, 28.(r2) ; Moving black piece to the previous place.
              mov #1, 14.(r2) ; Removing eaten white piece.
              mov #2, (r2)
              mov r2, 12.(sp) ; Updating father src.
              mov 28.(r2), 10.(sp) ; Updating father dest.
              br NextCell

              upMax7:
                cmp 6(sp), 30.(sp) ; Comparing wp to the wp of the father.
                ble noUpdate7
                mov 6(sp), 30.(sp) ; Updating father wp to new maximum.
                add #12, sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 28.(r2) ; Moving black piece to the new place.
                mov #1, 14.(r2) ; Removing eaten white piece.
                mov #2, (r2)
                mov r2, 12.(sp) ; Updating father src.
                mov 28.(r2), 10.(sp) ; Updating father dest.
                br NextCell

              noUpdate7:
                add #12., sp ; Popping all values besides registers backup.
                mov (sp)+, r5
                mov (sp)+, r3
                mov (sp)+, r2
                mov (sp)+, r1
                mov (sp)+, r0
                mov #0, 28.(r2) ; Moving black piece to the new place.
                mov #1, 14.(r2) ; Removing eaten white piece.
                mov #2, (r2)
                br NextCell ; No more moving options, move to the next cell.

.=torg+5000

Board:
      .word 0, 0, 0, 0, 0, 0, 0, 0
      .word 0, 0, 1, 0, 0, 0, 0, 0
      .word 0, 2, 0, 0, 0, 0, 0, 0
      .word 0, 0, 0, 0, 0, 0, 0, 0
      .word 0, 0, 0, 0, 0, 0, 0, 0
      .word 0, 0, 0, 0, 0, 0, 0, 0
      .word 0, 0, 0, 0, 0, 0, 0, 0
      .word 0, 0, 0, 0, 0, 0, 0, 0

Player: .word 1
Steps: .word 2
